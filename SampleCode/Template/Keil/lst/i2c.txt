; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\i2c.crf ..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;98       */
;;;99     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;100    {
;;;101        i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;102    }
000008  4770              BX       lr
;;;103    
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;70     
;;;71     void I2C_Close(I2C_T *i2c)
000000  4a0a              LDR      r2,|L2.44|
;;;72     {
;;;73         /* Reset I2C Controller */
;;;74         if (i2c == I2C0)
;;;75         {
;;;76             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  02d1              LSLS     r1,r2,#11
000004  4290              CMP      r0,r2                 ;74
000006  d102              BNE      |L2.14|
000008  68cb              LDR      r3,[r1,#0xc]
00000a  1582              ASRS     r2,r0,#22
;;;77             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
00000c  e004              B        |L2.24|
                  |L2.14|
;;;78         }
;;;79         else if (i2c == I2C1)
00000e  4a08              LDR      r2,|L2.48|
000010  4290              CMP      r0,r2
000012  d106              BNE      |L2.34|
;;;80         {
;;;81             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
000014  68cb              LDR      r3,[r1,#0xc]
000016  1542              ASRS     r2,r0,#21
                  |L2.24|
000018  4313              ORRS     r3,r3,r2
00001a  60cb              STR      r3,[r1,#0xc]
;;;82             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
00001c  68cb              LDR      r3,[r1,#0xc]
00001e  4393              BICS     r3,r3,r2
000020  60cb              STR      r3,[r1,#0xc]
                  |L2.34|
;;;83         }
;;;84     
;;;85         /* Disable I2C */
;;;86         i2c->CTL0 &= ~I2C_CTL0_I2CEN_Msk;
000022  6801              LDR      r1,[r0,#0]
000024  2240              MOVS     r2,#0x40
000026  4391              BICS     r1,r1,r2
000028  6001              STR      r1,[r0,#0]
;;;87     }
00002a  4770              BX       lr
;;;88     
                          ENDP

                  |L2.44|
                          DCD      0x40080000
                  |L2.48|
                          DCD      0x40081000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;154      */
;;;155    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;156    {
;;;157        i2c->CTL0 &= ~I2C_CTL0_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;158    }
000008  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;395     */
;;;396    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;397    {
;;;398        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;399    }
000008  4770              BX       lr
;;;400    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;425     */
;;;426    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;427    {
;;;428        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;429    }
000008  4770              BX       lr
;;;430    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;169      */
;;;170    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;171    {
;;;172        i2c->CTL0 |= I2C_CTL0_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;173    }
000008  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;371     */
;;;372    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2202              MOVS     r2,#2
;;;373    {
;;;374        if (u8LongTimeout)
000002  2900              CMP      r1,#0
;;;375        {
;;;376            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;377        }
;;;378        else
;;;379        {
;;;380            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000004  6941              LDR      r1,[r0,#0x14]
000006  d001              BEQ      |L7.12|
000008  4311              ORRS     r1,r1,r2              ;376
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4391              BICS     r1,r1,r2
                  |L7.14|
00000e  6141              STR      r1,[r0,#0x14]
;;;381        }
;;;382    
;;;383        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6141              STR      r1,[r0,#0x14]
;;;384    }
000018  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;410     */
;;;411    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;412    {
;;;413        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  63c1              STR      r1,[r0,#0x3c]
;;;414    }
000008  4770              BX       lr
;;;415    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;183     */
;;;184    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186        uint32_t u32Divider = i2c->CLKDIV;
000002  6904              LDR      r4,[r0,#0x10]
;;;187        uint32_t u32Pclk;
;;;188    
;;;189        if (i2c == I2C1)
000004  4906              LDR      r1,|L9.32|
000006  4288              CMP      r0,r1
000008  d102              BNE      |L9.16|
;;;190        {
;;;191            u32Pclk = CLK_GetPCLK1Freq();
00000a  f7fffffe          BL       CLK_GetPCLK1Freq
00000e  e001              B        |L9.20|
                  |L9.16|
;;;192        }
;;;193        else
;;;194        {
;;;195            u32Pclk = CLK_GetPCLK0Freq();
000010  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L9.20|
;;;196        }
;;;197    
;;;198        return (u32Pclk / ((u32Divider + 1U) << 2U));
000014  00a1              LSLS     r1,r4,#2
000016  1d09              ADDS     r1,r1,#4
000018  f7fffffe          BL       __aeabi_uidivmod
;;;199    }
00001c  bd10              POP      {r4,pc}
;;;200    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40081000

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;267     */
;;;268    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;269    {
;;;270        return (uint8_t)(i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;271    }
000004  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;239     */
;;;240    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;241    {
;;;242        return ((i2c->CTL0 & I2C_CTL0_SI_Msk) == I2C_CTL0_SI_Msk ? 1U : 0U);
000002  0700              LSLS     r0,r0,#28
000004  0fc0              LSRS     r0,r0,#31
;;;243    }
000006  4770              BX       lr
;;;244    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;253     */
;;;254    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;255    {
;;;256        return (i2c->STATUS0);
;;;257    }
000002  4770              BX       lr
;;;258    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;36       */
;;;37     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;38     {
000002  4605              MOV      r5,r0
;;;39         uint32_t u32Div;
;;;40         uint32_t u32Pclk;
;;;41     
;;;42         if (i2c == I2C1)
000004  480f              LDR      r0,|L13.68|
000006  460e              MOV      r6,r1                 ;38
000008  4285              CMP      r5,r0
00000a  d102              BNE      |L13.18|
;;;43         {
;;;44             u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L13.22|
                  |L13.18|
;;;45         }
;;;46         else
;;;47         {
;;;48             u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L13.22|
000016  4604              MOV      r4,r0
;;;49         }
;;;50     
;;;51         u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000018  220a              MOVS     r2,#0xa
00001a  00b1              LSLS     r1,r6,#2
00001c  4350              MULS     r0,r2,r0
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  210a              MOVS     r1,#0xa
000024  1d40              ADDS     r0,r0,#5
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  1e40              SUBS     r0,r0,#1
;;;52         i2c->CLKDIV = u32Div;
00002c  6128              STR      r0,[r5,#0x10]
;;;53     
;;;54         /* Enable I2C */
;;;55         i2c->CTL0 |= I2C_CTL0_I2CEN_Msk;
00002e  6829              LDR      r1,[r5,#0]
000030  2240              MOVS     r2,#0x40
000032  4311              ORRS     r1,r1,r2
000034  6029              STR      r1,[r5,#0]
;;;56     
;;;57         return (u32Pclk / ((u32Div + 1U) << 2U));
000036  0081              LSLS     r1,r0,#2
000038  4620              MOV      r0,r4
00003a  1d09              ADDS     r1,r1,#4
00003c  f7fffffe          BL       __aeabi_uidivmod
;;;58     }
000040  bd70              POP      {r4-r6,pc}
;;;59     
                          ENDP

000042  0000              DCW      0x0000
                  |L13.68|
                          DCD      0x40081000

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;1088     */
;;;1089   uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1090   {
;;;1091       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  2300              MOVS     r3,#0
;;;1092   
;;;1093       I2C_START(i2c);                                          /* Send START */
000006  6802              LDR      r2,[r0,#0]
000008  461c              MOV      r4,r3                 ;1091
00000a  2628              MOVS     r6,#0x28
00000c  4332              ORRS     r2,r2,r6
00000e  6002              STR      r2,[r0,#0]
;;;1094   
;;;1095       while (u8Xfering && (u8Err == 0U))
;;;1096       {
;;;1097           I2C_WAIT_READY(i2c) {}
;;;1098   
;;;1099           switch (I2C_GET_STATUS(i2c))
;;;1100           {
;;;1101           case 0x08:
;;;1102               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
;;;1103               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1104               break;
;;;1105   
;;;1106           case 0x40:                                           /* Slave Address ACK */
;;;1107               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1108               break;
;;;1109   
;;;1110           case 0x48:                                           /* Slave Address NACK */
;;;1111               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1112               u8Err = 1U;
;;;1113               break;
;;;1114   
;;;1115           case 0x58:
;;;1116               rdata = (uint8_t) I2C_GET_DATA(i2c);       /* Receive Data */
;;;1117               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1118               u8Xfering = 0U;
;;;1119               break;
;;;1120   
;;;1121           case 0x38:                                           /* Arbitration Lost */
;;;1122           default:                                             /* Unknow status */
;;;1123               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L14.18|
000012  6802              LDR      r2,[r0,#0]            ;1097
000014  0712              LSLS     r2,r2,#28             ;1097
000016  d5fc              BPL      |L14.18|
000018  68c2              LDR      r2,[r0,#0xc]          ;1099
00001a  2a08              CMP      r2,#8                 ;1099
00001c  d00b              BEQ      |L14.54|
00001e  2a40              CMP      r2,#0x40              ;1099
000020  d00d              BEQ      |L14.62|
000022  2a48              CMP      r2,#0x48              ;1099
000024  d00d              BEQ      |L14.66|
000026  2a58              CMP      r2,#0x58              ;1099
000028  d00e              BEQ      |L14.72|
00002a  6802              LDR      r2,[r0,#0]
00002c  43b2              BICS     r2,r2,r6
00002e  3218              ADDS     r2,r2,#0x18
000030  6002              STR      r2,[r0,#0]
;;;1124               u8Ctrl = I2C_CTL_SI;
000032  2208              MOVS     r2,#8
;;;1125               u8Err = 1U;
;;;1126               break;
000034  e006              B        |L14.68|
                  |L14.54|
000036  004a              LSLS     r2,r1,#1              ;1102
000038  1c52              ADDS     r2,r2,#1              ;1102
00003a  b2d2              UXTB     r2,r2                 ;1102
00003c  6082              STR      r2,[r0,#8]            ;1102
                  |L14.62|
00003e  2208              MOVS     r2,#8                 ;1107
000040  e006              B        |L14.80|
                  |L14.66|
000042  2218              MOVS     r2,#0x18              ;1111
                  |L14.68|
000044  2301              MOVS     r3,#1                 ;1112
000046  e003              B        |L14.80|
                  |L14.72|
000048  6882              LDR      r2,[r0,#8]            ;1116
00004a  b2d4              UXTB     r4,r2                 ;1116
00004c  2218              MOVS     r2,#0x18              ;1117
00004e  2500              MOVS     r5,#0                 ;1118
                  |L14.80|
;;;1127           }
;;;1128   
;;;1129           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000050  6807              LDR      r7,[r0,#0]
000052  43b7              BICS     r7,r7,r6
000054  4317              ORRS     r7,r7,r2
000056  6007              STR      r7,[r0,#0]
000058  2d00              CMP      r5,#0                 ;1095
00005a  d002              BEQ      |L14.98|
00005c  2b00              CMP      r3,#0                 ;1095
00005e  d0d8              BEQ      |L14.18|
000060  e001              B        |L14.102|
                  |L14.98|
;;;1130       }
;;;1131   
;;;1132       if (u8Err)
000062  2b00              CMP      r3,#0
000064  d000              BEQ      |L14.104|
                  |L14.102|
;;;1133           rdata = 0U;                                           /* If occurs error, return 0 */
000066  2400              MOVS     r4,#0
                  |L14.104|
;;;1134   
;;;1135       return rdata;                                            /* Return read data */
000068  4620              MOV      r0,r4
;;;1136   }
00006a  bdf0              POP      {r4-r7,pc}
;;;1137   /**
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;1225     */
;;;1226   uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1227   {
;;;1228       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Ctrl = 0U;
000002  2601              MOVS     r6,#1
000004  2400              MOVS     r4,#0
;;;1229   
;;;1230       I2C_START(i2c);                                          /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  4625              MOV      r5,r4                 ;1228
00000a  4622              MOV      r2,r4                 ;1228
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;1231   
;;;1232       while (u8Xfering && (u8Err == 0U))
;;;1233       {
;;;1234           I2C_WAIT_READY(i2c) {}
;;;1235   
;;;1236           switch (I2C_GET_STATUS(i2c))
;;;1237           {
;;;1238           case 0x08:
;;;1239               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L15.20|
000014  6801              LDR      r1,[r0,#0]            ;1234
000016  0709              LSLS     r1,r1,#28             ;1234
000018  d5fc              BPL      |L15.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;1236
00001c  074b              LSLS     r3,r1,#29             ;1236
00001e  0f5b              LSRS     r3,r3,#29             ;1236
000020  d127              BNE      |L15.114|
000022  10c9              ASRS     r1,r1,#3              ;1236
000024  000b              MOVS     r3,r1                 ;1236
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c24              DCB      0x0c,0x24
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c2414          DCB      0x0f,0x0c,0x24,0x14
000034  0c241624          DCB      0x0c,0x24,0x16,0x24
000038  b2f9              UXTB     r1,r7
;;;1240               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1241               break;
00003a  e009              B        |L15.80|
;;;1242   
;;;1243           case 0x18:                                           /* Slave Address ACK */
;;;1244               I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;1245               break;
000040  e00d              B        |L15.94|
;;;1246   
;;;1247           case 0x20:                                           /* Slave Address NACK */
;;;1248           case 0x30:                                           /* Master transmit data NACK */
;;;1249               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L15.68|
;;;1250               u8Err = 1U;
000044  2401              MOVS     r4,#1
000046  e00a              B        |L15.94|
;;;1251               break;
;;;1252   
;;;1253           case 0x28:
;;;1254               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;1255               break;
00004a  e008              B        |L15.94|
;;;1256   
;;;1257           case 0x10:
;;;1258               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  b2c9              UXTB     r1,r1
                  |L15.80|
000050  6081              STR      r1,[r0,#8]            ;1239
;;;1259               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1260               break;
;;;1261   
;;;1262           case 0x40:                                           /* Slave Address ACK */
;;;1263               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
000052  2208              MOVS     r2,#8
;;;1264               break;
000054  e003              B        |L15.94|
;;;1265   
;;;1266           case 0x48:                                           /* Slave Address NACK */
;;;1267               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1268               u8Err = 1U;
;;;1269               break;
;;;1270   
;;;1271           case 0x58:
;;;1272               rdata = (uint8_t) I2C_GET_DATA(i2c);             /* Receive Data */
000056  6881              LDR      r1,[r0,#8]
;;;1273               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000058  2218              MOVS     r2,#0x18
00005a  b2cd              UXTB     r5,r1                 ;1272
;;;1274               u8Xfering = 0U;
00005c  2600              MOVS     r6,#0
                  |L15.94|
;;;1275               break;
;;;1276   
;;;1277           case 0x38:                                           /* Arbitration Lost */
;;;1278           default:                                             /* Unknow status */
;;;1279               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1280               u8Ctrl = I2C_CTL_SI;
;;;1281               u8Err = 1U;
;;;1282               break;
;;;1283           }
;;;1284   
;;;1285           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
00005e  6801              LDR      r1,[r0,#0]
000060  233c              MOVS     r3,#0x3c
000062  4399              BICS     r1,r1,r3
000064  4311              ORRS     r1,r1,r2
000066  6001              STR      r1,[r0,#0]
000068  2e00              CMP      r6,#0                 ;1232
00006a  d009              BEQ      |L15.128|
00006c  2c00              CMP      r4,#0                 ;1232
00006e  d0d1              BEQ      |L15.20|
000070  e008              B        |L15.132|
                  |L15.114|
000072  6801              LDR      r1,[r0,#0]            ;1279
000074  223c              MOVS     r2,#0x3c              ;1279
000076  4391              BICS     r1,r1,r2              ;1279
000078  3118              ADDS     r1,r1,#0x18           ;1279
00007a  6001              STR      r1,[r0,#0]            ;1279
00007c  2208              MOVS     r2,#8                 ;1280
00007e  e7e1              B        |L15.68|
                  |L15.128|
;;;1286       }
;;;1287   
;;;1288       if (u8Err)
000080  2c00              CMP      r4,#0
000082  d000              BEQ      |L15.134|
                  |L15.132|
;;;1289           rdata = 0U;                                           /* If occurs error, return 0 */
000084  2500              MOVS     r5,#0
                  |L15.134|
;;;1290   
;;;1291       return rdata;                                            /* Return read data */
000086  4628              MOV      r0,r5
;;;1292   }
000088  bdfe              POP      {r1-r7,pc}
;;;1293   
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1397     */
;;;1398   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1399   {
;;;1400       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1399
000006  2400              MOVS     r4,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1401   
;;;1402       I2C_START(i2c);                                                   /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  4625              MOV      r5,r4                 ;1400
000010  4622              MOV      r2,r4                 ;1400
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1403   
;;;1404       while (u8Xfering && (u8Err == 0U))
;;;1405       {
;;;1406           I2C_WAIT_READY(i2c) {}
;;;1407   
;;;1408           switch (I2C_GET_STATUS(i2c))
;;;1409           {
;;;1410           case 0x08:
;;;1411               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));             /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L16.26|
00001a  6801              LDR      r1,[r0,#0]            ;1406
00001c  0709              LSLS     r1,r1,#28             ;1406
00001e  d5fc              BPL      |L16.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1408
000022  074b              LSLS     r3,r1,#29             ;1408
000024  0f5b              LSRS     r3,r3,#29             ;1408
000026  d131              BNE      |L16.140|
000028  10c9              ASRS     r1,r1,#3              ;1408
00002a  000b              MOVS     r3,r1                 ;1408
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c2e0719          DCB      0x0c,0x2e,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  2e1c0d2e          DCB      0x2e,0x1c,0x0d,0x2e
00003c  1e2e              DCB      0x1e,0x2e
00003e  b2f9              UXTB     r1,r7
;;;1412               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1413               break;
000040  e011              B        |L16.102|
;;;1414   
;;;1415           case 0x18:                                                    /* Slave Address ACK */
;;;1416               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));/* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1417               break;
000048  e015              B        |L16.118|
;;;1418   
;;;1419           case 0x20:                                                    /* Slave Address NACK */
;;;1420           case 0x30:                                                    /* Master transmit data NACK */
;;;1421               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L16.76|
;;;1422               u8Err = 1U;
00004c  2401              MOVS     r4,#1
00004e  e012              B        |L16.118|
;;;1423               break;
;;;1424   
;;;1425           case 0x28:
;;;1426               if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L16.94|
;;;1427               {
;;;1428                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));     /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1429                   u8Addr = 0U;
00005a  2600              MOVS     r6,#0
00005c  e00b              B        |L16.118|
                  |L16.94|
;;;1430               }
;;;1431               else
;;;1432                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e009              B        |L16.118|
;;;1433   
;;;1434               break;
;;;1435   
;;;1436           case 0x10:
;;;1437               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));           /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  b2c9              UXTB     r1,r1
                  |L16.102|
000066  6081              STR      r1,[r0,#8]            ;1411
;;;1438               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1439               break;
;;;1440   
;;;1441           case 0x40:                                                    /* Slave Address ACK */
;;;1442               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
000068  2208              MOVS     r2,#8
;;;1443               break;
00006a  e004              B        |L16.118|
;;;1444   
;;;1445           case 0x48:                                                    /* Slave Address NACK */
;;;1446               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1447               u8Err = 1U;
;;;1448               break;
;;;1449   
;;;1450           case 0x58:
;;;1451               rdata = (uint8_t) I2C_GET_DATA(i2c);                /* Receive Data */
00006c  6881              LDR      r1,[r0,#8]
;;;1452               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00006e  2218              MOVS     r2,#0x18
000070  b2cd              UXTB     r5,r1                 ;1451
;;;1453               u8Xfering = 0U;
000072  2100              MOVS     r1,#0
000074  9100              STR      r1,[sp,#0]
                  |L16.118|
;;;1454               break;
;;;1455   
;;;1456           case 0x38:                                                    /* Arbitration Lost */
;;;1457           default:                                                      /* Unknow status */
;;;1458               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1459               u8Ctrl = I2C_CTL_SI;
;;;1460               u8Err = 1U;
;;;1461               break;
;;;1462           }
;;;1463   
;;;1464           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                             /* Write controlbit to I2C_CTL register */
000076  6801              LDR      r1,[r0,#0]
000078  233c              MOVS     r3,#0x3c
00007a  4399              BICS     r1,r1,r3
00007c  4311              ORRS     r1,r1,r2
00007e  6001              STR      r1,[r0,#0]
000080  9900              LDR      r1,[sp,#0]            ;1404
000082  2900              CMP      r1,#0                 ;1404
000084  d009              BEQ      |L16.154|
000086  2c00              CMP      r4,#0                 ;1404
000088  d0c7              BEQ      |L16.26|
00008a  e008              B        |L16.158|
                  |L16.140|
00008c  6801              LDR      r1,[r0,#0]            ;1458
00008e  223c              MOVS     r2,#0x3c              ;1458
000090  4391              BICS     r1,r1,r2              ;1458
000092  3118              ADDS     r1,r1,#0x18           ;1458
000094  6001              STR      r1,[r0,#0]            ;1458
000096  2208              MOVS     r2,#8                 ;1459
000098  e7d8              B        |L16.76|
                  |L16.154|
;;;1465       }
;;;1466   
;;;1467       if (u8Err)
00009a  2c00              CMP      r4,#0
00009c  d000              BEQ      |L16.160|
                  |L16.158|
;;;1468           rdata = 0U;                                                    /* If occurs error, return 0 */
00009e  2500              MOVS     r5,#0
                  |L16.160|
;;;1469   
;;;1470       return rdata;                                                     /* Return read data */
0000a0  4628              MOV      r0,r5
;;;1471   }
0000a2  b004              ADD      sp,sp,#0x10
0000a4  bdf0              POP      {r4-r7,pc}
;;;1472   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;1150     */
;;;1151   uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1152   {
000002  468c              MOV      r12,r1
;;;1153       uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  2600              MOVS     r6,#0
;;;1154       uint32_t u32rxLen = 0U;
;;;1155   
;;;1156       I2C_START(i2c);                                          /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  469e              MOV      lr,r3                 ;1152
00000c  4634              MOV      r4,r6                 ;1154
00000e  2528              MOVS     r5,#0x28
000010  4329              ORRS     r1,r1,r5
000012  6001              STR      r1,[r0,#0]
;;;1157   
;;;1158       while (u8Xfering && (u8Err == 0U))
;;;1159       {
;;;1160           I2C_WAIT_READY(i2c) {}
;;;1161   
;;;1162           switch (I2C_GET_STATUS(i2c))
;;;1163           {
;;;1164           case 0x08:
;;;1165               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
;;;1166               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1167               break;
;;;1168   
;;;1169           case 0x40:                                           /* Slave Address ACK */
;;;1170               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1171               break;
;;;1172   
;;;1173           case 0x48:                                           /* Slave Address NACK */
;;;1174               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1175               u8Err = 1;
;;;1176               break;
;;;1177   
;;;1178           case 0x50:
;;;1179               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);  /* Receive Data */
;;;1180   
;;;1181               if (u32rxLen < (u32rLen - 1))
;;;1182               {
;;;1183                   u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
;;;1184               }
;;;1185               else
;;;1186               {
;;;1187                   u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
;;;1188               }
;;;1189   
;;;1190               break;
;;;1191   
;;;1192           case 0x58:
;;;1193               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);  /* Receive Data */
;;;1194               u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;1195               u8Xfering = 0U;
;;;1196               break;
;;;1197   
;;;1198           case 0x38:                                                  /* Arbitration Lost */
;;;1199           default:                                                    /* Unknow status */
;;;1200               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);               /* Clear SI and send STOP */
000014  213c              MOVS     r1,#0x3c
                  |L17.22|
000016  6805              LDR      r5,[r0,#0]            ;1160
000018  072d              LSLS     r5,r5,#28             ;1160
00001a  d5fc              BPL      |L17.22|
00001c  68c5              LDR      r5,[r0,#0xc]          ;1162
00001e  2d48              CMP      r5,#0x48              ;1162
000020  d015              BEQ      |L17.78|
000022  dc04              BGT      |L17.46|
000024  2d08              CMP      r5,#8                 ;1162
000026  d00c              BEQ      |L17.66|
000028  2d40              CMP      r5,#0x40              ;1162
00002a  d104              BNE      |L17.54|
00002c  e019              B        |L17.98|
                  |L17.46|
00002e  2d50              CMP      r5,#0x50              ;1162
000030  d010              BEQ      |L17.84|
000032  2d58              CMP      r5,#0x58              ;1162
000034  d019              BEQ      |L17.106|
                  |L17.54|
000036  6805              LDR      r5,[r0,#0]
000038  438d              BICS     r5,r5,r1
00003a  3518              ADDS     r5,r5,#0x18
00003c  6005              STR      r5,[r0,#0]
;;;1201               u8Ctrl = I2C_CTL_SI;
00003e  2508              MOVS     r5,#8
;;;1202               u8Err = 1U;
;;;1203               break;
000040  e006              B        |L17.80|
                  |L17.66|
000042  4663              MOV      r3,r12                ;1165
000044  005d              LSLS     r5,r3,#1              ;1165
000046  1c6d              ADDS     r5,r5,#1              ;1165
000048  b2ed              UXTB     r5,r5                 ;1165
00004a  6085              STR      r5,[r0,#8]            ;1165
00004c  e00b              B        |L17.102|
                  |L17.78|
00004e  2518              MOVS     r5,#0x18              ;1174
                  |L17.80|
000050  2601              MOVS     r6,#1                 ;1175
000052  e00f              B        |L17.116|
                  |L17.84|
000054  6885              LDR      r5,[r0,#8]            ;1179
000056  5515              STRB     r5,[r2,r4]            ;1179
000058  4673              MOV      r3,lr                 ;1181
00005a  1e5b              SUBS     r3,r3,#1              ;1181
00005c  1c64              ADDS     r4,r4,#1              ;1181
00005e  429c              CMP      r4,r3                 ;1181
000060  d201              BCS      |L17.102|
                  |L17.98|
000062  250c              MOVS     r5,#0xc               ;1183
000064  e006              B        |L17.116|
                  |L17.102|
000066  2508              MOVS     r5,#8                 ;1187
000068  e004              B        |L17.116|
                  |L17.106|
00006a  6885              LDR      r5,[r0,#8]            ;1193
00006c  5515              STRB     r5,[r2,r4]            ;1193
00006e  2518              MOVS     r5,#0x18              ;1194
000070  2700              MOVS     r7,#0                 ;1195
000072  1c64              ADDS     r4,r4,#1              ;1195
                  |L17.116|
;;;1204           }
;;;1205   
;;;1206           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                           /* Write controlbit to I2C_CTL register */
000074  6803              LDR      r3,[r0,#0]
000076  438b              BICS     r3,r3,r1
000078  431d              ORRS     r5,r5,r3
00007a  6005              STR      r5,[r0,#0]
00007c  2f00              CMP      r7,#0                 ;1158
00007e  d001              BEQ      |L17.132|
000080  2e00              CMP      r6,#0                 ;1158
000082  d0c8              BEQ      |L17.22|
                  |L17.132|
;;;1207       }
;;;1208   
;;;1209       return u32rxLen;                                                /* Return bytes length that have been received */
000084  4620              MOV      r0,r4
;;;1210   }
000086  bdf0              POP      {r4-r7,pc}
;;;1211   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;1308     */
;;;1309   uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1310   {
;;;1311       uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000002  2601              MOVS     r6,#1
000004  2500              MOVS     r5,#0
;;;1312       uint32_t u32rxLen = 0U;
;;;1313   
;;;1314       I2C_START(i2c);                                          /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  462a              MOV      r2,r5                 ;1311
00000a  462c              MOV      r4,r5                 ;1312
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;1315   
;;;1316       while (u8Xfering && (u8Err == 0U))
;;;1317       {
;;;1318           I2C_WAIT_READY(i2c) {}
;;;1319   
;;;1320           switch (I2C_GET_STATUS(i2c))
;;;1321           {
;;;1322           case 0x08:
;;;1323               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L18.20|
000014  6801              LDR      r1,[r0,#0]            ;1318
000016  0709              LSLS     r1,r1,#28             ;1318
000018  d5fc              BPL      |L18.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;1320
00001c  074b              LSLS     r3,r1,#29             ;1320
00001e  0f5b              LSRS     r3,r3,#29             ;1320
000020  d136              BNE      |L18.144|
000022  10c9              ASRS     r1,r1,#3              ;1320
000024  000b              MOVS     r3,r1                 ;1320
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c33              DCB      0x0c,0x33
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c331d          DCB      0x0f,0x0c,0x33,0x1d
000034  0c152133          DCB      0x0c,0x15,0x21,0x33
000038  b2f9              UXTB     r1,r7
;;;1324               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1325               break;
00003a  e009              B        |L18.80|
;;;1326   
;;;1327           case 0x18:                                           /* Slave Address ACK */
;;;1328               I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;1329               break;
000040  e01a              B        |L18.120|
;;;1330   
;;;1331           case 0x20:                                           /* Slave Address NACK */
;;;1332           case 0x30:                                           /* Master transmit data NACK */
;;;1333               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L18.68|
;;;1334               u8Err = 1U;
000044  2501              MOVS     r5,#1
000046  e017              B        |L18.120|
;;;1335               break;
;;;1336   
;;;1337           case 0x28:
;;;1338               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;1339               break;
00004a  e015              B        |L18.120|
;;;1340   
;;;1341           case 0x10:
;;;1342               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  b2c9              UXTB     r1,r1
                  |L18.80|
000050  6081              STR      r1,[r0,#8]
000052  e009              B        |L18.104|
;;;1343               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1344               break;
;;;1345   
;;;1346           case 0x40:                                           /* Slave Address ACK */
;;;1347               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1348               break;
;;;1349   
;;;1350           case 0x48:                                           /* Slave Address NACK */
;;;1351               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1352               u8Err = 1U;
;;;1353               break;
;;;1354   
;;;1355           case 0x50:
;;;1356               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c); /* Receive Data */
000054  6881              LDR      r1,[r0,#8]
000056  9a03              LDR      r2,[sp,#0xc]
000058  5511              STRB     r1,[r2,r4]
;;;1357   
;;;1358               if (u32rxLen < (u32rLen - 1U))
00005a  9909              LDR      r1,[sp,#0x24]
00005c  1c64              ADDS     r4,r4,#1
00005e  1e49              SUBS     r1,r1,#1
000060  428c              CMP      r4,r1
000062  d201              BCS      |L18.104|
;;;1359                   u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
000064  220c              MOVS     r2,#0xc
000066  e007              B        |L18.120|
                  |L18.104|
;;;1360               else
;;;1361                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000068  2208              MOVS     r2,#8
00006a  e005              B        |L18.120|
;;;1362   
;;;1363               break;
;;;1364   
;;;1365           case 0x58:
;;;1366               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c); /* Receive Data */
00006c  6881              LDR      r1,[r0,#8]
00006e  9a03              LDR      r2,[sp,#0xc]
;;;1367               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1368               u8Xfering = 0U;
000070  2600              MOVS     r6,#0
000072  5511              STRB     r1,[r2,r4]            ;1366
000074  2218              MOVS     r2,#0x18              ;1367
000076  1c64              ADDS     r4,r4,#1
                  |L18.120|
;;;1369               break;
;;;1370   
;;;1371           case 0x38:                                           /* Arbitration Lost */
;;;1372           default:                                             /* Unknow status */
;;;1373               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1374               u8Ctrl = I2C_CTL_SI;
;;;1375               u8Err = 1U;
;;;1376               break;
;;;1377           }
;;;1378   
;;;1379           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000078  6801              LDR      r1,[r0,#0]
00007a  233c              MOVS     r3,#0x3c
00007c  4399              BICS     r1,r1,r3
00007e  4311              ORRS     r1,r1,r2
000080  6001              STR      r1,[r0,#0]
000082  2e00              CMP      r6,#0                 ;1316
000084  d001              BEQ      |L18.138|
000086  2d00              CMP      r5,#0                 ;1316
000088  d0c4              BEQ      |L18.20|
                  |L18.138|
;;;1380       }
;;;1381   
;;;1382       return u32rxLen;                                         /* Return bytes length that have been received */
00008a  4620              MOV      r0,r4
;;;1383   }
00008c  b004              ADD      sp,sp,#0x10
00008e  bdf0              POP      {r4-r7,pc}
                  |L18.144|
000090  6801              LDR      r1,[r0,#0]            ;1373
000092  223c              MOVS     r2,#0x3c              ;1373
000094  4391              BICS     r1,r1,r2              ;1373
000096  3118              ADDS     r1,r1,#0x18           ;1373
000098  6001              STR      r1,[r0,#0]            ;1373
00009a  2208              MOVS     r2,#8                 ;1374
00009c  e7d2              B        |L18.68|
;;;1384   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1487     */
;;;1488   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1489   {
;;;1490       uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1489
000006  2500              MOVS     r5,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1491       uint32_t u32rxLen = 0U;
;;;1492   
;;;1493       I2C_START(i2c);                                                   /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  462a              MOV      r2,r5                 ;1490
000010  462c              MOV      r4,r5                 ;1491
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1494   
;;;1495       while (u8Xfering && (u8Err == 0U))
;;;1496       {
;;;1497           I2C_WAIT_READY(i2c) {}
;;;1498   
;;;1499           switch (I2C_GET_STATUS(i2c))
;;;1500           {
;;;1501           case 0x08:
;;;1502               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));             /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L19.26|
00001a  6801              LDR      r1,[r0,#0]            ;1497
00001c  0709              LSLS     r1,r1,#28             ;1497
00001e  d5fc              BPL      |L19.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1499
000022  074b              LSLS     r3,r1,#29             ;1499
000024  0f5b              LSRS     r3,r3,#29             ;1499
000026  d140              BNE      |L19.170|
000028  10c9              ASRS     r1,r1,#3              ;1499
00002a  000b              MOVS     r3,r1                 ;1499
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c3d0719          DCB      0x0c,0x3d,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  3d250d1d          DCB      0x3d,0x25,0x0d,0x1d
00003c  293d              DCB      0x29,0x3d
00003e  b2f9              UXTB     r1,r7
;;;1503               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1504               break;
000040  e011              B        |L19.102|
;;;1505   
;;;1506           case 0x18:                                                    /* Slave Address ACK */
;;;1507               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));/* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1508               break;
000048  e022              B        |L19.144|
;;;1509   
;;;1510           case 0x20:                                                    /* Slave Address NACK */
;;;1511           case 0x30:                                                    /* Master transmit data NACK */
;;;1512               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L19.76|
;;;1513               u8Err = 1U;
00004c  2501              MOVS     r5,#1
00004e  e01f              B        |L19.144|
;;;1514               break;
;;;1515   
;;;1516           case 0x28:
;;;1517               if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L19.94|
;;;1518               {
;;;1519                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));     /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1520                   u8Addr = 0U;
00005a  2600              MOVS     r6,#0
00005c  e018              B        |L19.144|
                  |L19.94|
;;;1521               }
;;;1522               else
;;;1523                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e016              B        |L19.144|
;;;1524   
;;;1525               break;
;;;1526   
;;;1527           case 0x10:
;;;1528               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));           /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  b2c9              UXTB     r1,r1
                  |L19.102|
000066  6081              STR      r1,[r0,#8]
000068  e009              B        |L19.126|
;;;1529               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1530               break;
;;;1531   
;;;1532           case 0x40:                                                    /* Slave Address ACK */
;;;1533               u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1534               break;
;;;1535   
;;;1536           case 0x48:                                                    /* Slave Address NACK */
;;;1537               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1538               u8Err = 1U;
;;;1539               break;
;;;1540   
;;;1541           case 0x50:
;;;1542               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);    /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
00006c  9a04              LDR      r2,[sp,#0x10]
00006e  5511              STRB     r1,[r2,r4]
;;;1543   
;;;1544               if (u32rxLen < (u32rLen - 1U))
000070  990a              LDR      r1,[sp,#0x28]
000072  1c64              ADDS     r4,r4,#1
000074  1e49              SUBS     r1,r1,#1
000076  428c              CMP      r4,r1
000078  d201              BCS      |L19.126|
;;;1545               {
;;;1546                   u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
00007a  220c              MOVS     r2,#0xc
00007c  e008              B        |L19.144|
                  |L19.126|
;;;1547               }
;;;1548               else
;;;1549               {
;;;1550                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
00007e  2208              MOVS     r2,#8
000080  e006              B        |L19.144|
;;;1551               }
;;;1552   
;;;1553               break;
;;;1554   
;;;1555           case 0x58:
;;;1556               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);    /* Receive Data */
000082  6882              LDR      r2,[r0,#8]
000084  9904              LDR      r1,[sp,#0x10]
000086  550a              STRB     r2,[r1,r4]
;;;1557               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1558               u8Xfering = 0U;
000088  2100              MOVS     r1,#0
00008a  2218              MOVS     r2,#0x18              ;1557
00008c  1c64              ADDS     r4,r4,#1
00008e  9100              STR      r1,[sp,#0]
                  |L19.144|
;;;1559               break;
;;;1560   
;;;1561           case 0x38:                                                    /* Arbitration Lost */
;;;1562           default:                                                      /* Unknow status */
;;;1563               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1564               u8Ctrl = I2C_CTL_SI;
;;;1565               u8Err = 1U;
;;;1566               break;
;;;1567           }
;;;1568   
;;;1569           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                             /* Write controlbit to I2C_CTL register */
000090  6801              LDR      r1,[r0,#0]
000092  233c              MOVS     r3,#0x3c
000094  4399              BICS     r1,r1,r3
000096  4311              ORRS     r1,r1,r2
000098  6001              STR      r1,[r0,#0]
00009a  9900              LDR      r1,[sp,#0]            ;1495
00009c  2900              CMP      r1,#0                 ;1495
00009e  d001              BEQ      |L19.164|
0000a0  2d00              CMP      r5,#0                 ;1495
0000a2  d0ba              BEQ      |L19.26|
                  |L19.164|
;;;1570       }
;;;1571   
;;;1572       return u32rxLen;                                                  /* Return bytes length that have been received */
0000a4  4620              MOV      r0,r4
;;;1573   }
0000a6  b005              ADD      sp,sp,#0x14
0000a8  bdf0              POP      {r4-r7,pc}
                  |L19.170|
0000aa  6801              LDR      r1,[r0,#0]            ;1563
0000ac  223c              MOVS     r2,#0x3c              ;1563
0000ae  4391              BICS     r1,r1,r2              ;1563
0000b0  3118              ADDS     r1,r1,#0x18           ;1563
0000b2  6001              STR      r1,[r0,#0]            ;1563
0000b4  2208              MOVS     r2,#8                 ;1564
0000b6  e7c9              B        |L19.76|
;;;1574   
                          ENDP


                          AREA ||i.I2C_SMBusClearInterruptFlag||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClearInterruptFlag PROC
;;;456     */
;;;457    void I2C_SMBusClearInterruptFlag(I2C_T *i2c, uint8_t u8SMBusIntFlag)
000000  6581              STR      r1,[r0,#0x58]
;;;458    {
;;;459        i2c->BUSSTS = u8SMBusIntFlag;
;;;460    }
000002  4770              BX       lr
;;;461    
                          ENDP


                          AREA ||i.I2C_SMBusClockLoTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClockLoTimeout PROC
;;;641    
;;;642    void I2C_SMBusClockLoTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  b570              PUSH     {r4-r6,lr}
;;;643    {
000002  4604              MOV      r4,r0
;;;644        uint32_t u32Div, u32Pclk_kHz;
;;;645    
;;;646        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000004  6d00              LDR      r0,[r0,#0x50]
000006  460d              MOV      r5,r1                 ;643
000008  2101              MOVS     r1,#1
00000a  0249              LSLS     r1,r1,#9
00000c  4388              BICS     r0,r0,r1
00000e  6520              STR      r0,[r4,#0x50]
;;;647    
;;;648        /* DIV4 disabled */
;;;649        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000010  6960              LDR      r0,[r4,#0x14]
000012  2604              MOVS     r6,#4
000014  43b0              BICS     r0,r0,r6
000016  6160              STR      r0,[r4,#0x14]
;;;650        u32Pclk_kHz = u32Pclk / 1000U;
000018  217d              MOVS     r1,#0x7d
00001a  00c9              LSLS     r1,r1,#3
00001c  4610              MOV      r0,r2
00001e  f7fffffe          BL       __aeabi_uidivmod
;;;651        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000022  4345              MULS     r5,r0,r5
000024  0ba8              LSRS     r0,r5,#14
000026  1e40              SUBS     r0,r0,#1
;;;652        if(u32Div <= 0xFFU)
000028  28ff              CMP      r0,#0xff
00002a  d905              BLS      |L21.56|
;;;653        {
;;;654            i2c->CLKTOUT = u32Div;
;;;655        }
;;;656        else
;;;657        {
;;;658            /* DIV4 enabled */
;;;659            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
00002c  6960              LDR      r0,[r4,#0x14]
00002e  4330              ORRS     r0,r0,r6
000030  6160              STR      r0,[r4,#0x14]
;;;660            i2c->CLKTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
000032  0c28              LSRS     r0,r5,#16
000034  1e40              SUBS     r0,r0,#1
000036  b2c0              UXTB     r0,r0
                  |L21.56|
000038  66a0              STR      r0,[r4,#0x68]         ;654
;;;661        }
;;;662    }
00003a  bd70              POP      {r4-r6,pc}
;;;663    
                          ENDP


                          AREA ||i.I2C_SMBusClose||, CODE, READONLY, ALIGN=1

                  I2C_SMBusClose PROC
;;;514     */
;;;515    void I2C_SMBusClose(I2C_T *i2c)
000000  2100              MOVS     r1,#0
;;;516    {
;;;517    
;;;518        i2c->BUSCTL = 0x00U;
000002  6501              STR      r1,[r0,#0x50]
;;;519    }
000004  4770              BX       lr
;;;520    
                          ENDP


                          AREA ||i.I2C_SMBusGetPECValue||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetPECValue PROC
;;;555     */
;;;556    uint8_t I2C_SMBusGetPECValue(I2C_T *i2c)
000000  6e00              LDR      r0,[r0,#0x60]
;;;557    {
;;;558        return (uint8_t)i2c->PKTCRC;
000002  b2c0              UXTB     r0,r0
;;;559    }
000004  4770              BX       lr
;;;560    
                          ENDP


                          AREA ||i.I2C_SMBusGetStatus||, CODE, READONLY, ALIGN=1

                  I2C_SMBusGetStatus PROC
;;;440     */
;;;441    uint32_t I2C_SMBusGetStatus(I2C_T *i2c)
000000  6d80              LDR      r0,[r0,#0x58]
;;;442    {
;;;443        return (i2c->BUSSTS);
;;;444    }
000002  4770              BX       lr
;;;445    
                          ENDP


                          AREA ||i.I2C_SMBusIdleTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusIdleTimeout PROC
;;;573    
;;;574    void I2C_SMBusIdleTimeout(I2C_T *i2c, uint32_t us, uint32_t u32Hclk)
000000  b570              PUSH     {r4-r6,lr}
;;;575    {
000002  4604              MOV      r4,r0
;;;576        uint32_t  u32Div, u32Hclk_kHz;
;;;577    
;;;578        i2c->BUSCTL |= I2C_BUSCTL_TIDLE_Msk;
000004  6d00              LDR      r0,[r0,#0x50]
000006  460e              MOV      r6,r1                 ;575
000008  2101              MOVS     r1,#1
00000a  0249              LSLS     r1,r1,#9
00000c  4308              ORRS     r0,r0,r1
00000e  6520              STR      r0,[r4,#0x50]
;;;579        u32Hclk_kHz = u32Hclk / 1000U;
000010  257d              MOVS     r5,#0x7d
000012  00ed              LSLS     r5,r5,#3
000014  4629              MOV      r1,r5
000016  4610              MOV      r0,r2
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  4601              MOV      r1,r0
00001e  4630              MOV      r0,r6
;;;580        u32Div = (((us * u32Hclk_kHz) / 1000U) >> 2U) - 1U;
000020  4348              MULS     r0,r1,r0
000022  4629              MOV      r1,r5
000024  f7fffffe          BL       __aeabi_uidivmod
000028  0880              LSRS     r0,r0,#2
00002a  1e40              SUBS     r0,r0,#1
;;;581        if(u32Div > 255U)
00002c  28ff              CMP      r0,#0xff
00002e  d900              BLS      |L25.50|
;;;582        {
;;;583            i2c->BUSTOUT = 0xFFU;
000030  20ff              MOVS     r0,#0xff
                  |L25.50|
;;;584        }
;;;585        else
;;;586        {
;;;587            i2c->BUSTOUT = u32Div;
000032  6660              STR      r0,[r4,#0x64]
;;;588        }
;;;589    
;;;590    }
000034  bd70              POP      {r4-r6,pc}
;;;591    
                          ENDP


                          AREA ||i.I2C_SMBusOpen||, CODE, READONLY, ALIGN=1

                  I2C_SMBusOpen PROC
;;;488     */
;;;489    void I2C_SMBusOpen(I2C_T *i2c, uint8_t u8HostDevice)
000000  6d02              LDR      r2,[r0,#0x50]
;;;490    {
;;;491        /* Clear  BMHEN, BMDEN of BUSCTL Register */
;;;492        i2c->BUSCTL &=  ~(I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BMDEN_Msk);
000002  230c              MOVS     r3,#0xc
000004  439a              BICS     r2,r2,r3
000006  6502              STR      r2,[r0,#0x50]
;;;493    
;;;494        /* Set SMBus Host/Device Mode, and enable Bus Management*/
;;;495        if(u8HostDevice == (uint8_t)I2C_SMBH_ENABLE)
000008  2901              CMP      r1,#1
;;;496        {
;;;497            i2c->BUSCTL |= (I2C_BUSCTL_BMHEN_Msk | I2C_BUSCTL_BUSEN_Msk);
;;;498        }
;;;499        else
;;;500        {
;;;501            i2c->BUSCTL |= (I2C_BUSCTL_BMDEN_Msk | I2C_BUSCTL_BUSEN_Msk);
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  d003              BEQ      |L26.22|
00000e  2284              MOVS     r2,#0x84
                  |L26.16|
000010  4311              ORRS     r1,r1,r2              ;497
000012  6501              STR      r1,[r0,#0x50]         ;497
;;;502        }
;;;503    }
000014  4770              BX       lr
                  |L26.22|
000016  2288              MOVS     r2,#0x88              ;497
000018  e7fa              B        |L26.16|
;;;504    
                          ENDP


                          AREA ||i.I2C_SMBusPECTxEnable||, CODE, READONLY, ALIGN=1

                  I2C_SMBusPECTxEnable PROC
;;;531     */
;;;532    void I2C_SMBusPECTxEnable(I2C_T *i2c, uint8_t u8PECTxEn)
000000  6d02              LDR      r2,[r0,#0x50]
;;;533    {
;;;534        i2c->BUSCTL &= ~I2C_BUSCTL_PECTXEN_Msk;
000002  23ff              MOVS     r3,#0xff
000004  3301              ADDS     r3,#1
000006  439a              BICS     r2,r2,r3
000008  6502              STR      r2,[r0,#0x50]
;;;535    
;;;536        if(u8PECTxEn)
00000a  2900              CMP      r1,#0
;;;537        {
;;;538            i2c->BUSCTL |= (I2C_BUSCTL_PECEN_Msk | I2C_BUSCTL_PECTXEN_Msk);
;;;539        }
;;;540        else
;;;541        {
;;;542            i2c->BUSCTL |= I2C_BUSCTL_PECEN_Msk;
00000c  6d01              LDR      r1,[r0,#0x50]
00000e  d001              BEQ      |L27.20|
000010  1c9a              ADDS     r2,r3,#2              ;538
000012  e000              B        |L27.22|
                  |L27.20|
000014  2202              MOVS     r2,#2
                  |L27.22|
000016  4311              ORRS     r1,r1,r2              ;538
000018  6501              STR      r1,[r0,#0x50]         ;538
;;;543        }
;;;544    }
00001a  4770              BX       lr
;;;545    
                          ENDP


                          AREA ||i.I2C_SMBusSetPacketByteCount||, CODE, READONLY, ALIGN=1

                  I2C_SMBusSetPacketByteCount PROC
;;;472     */
;;;473    void I2C_SMBusSetPacketByteCount(I2C_T *i2c, uint32_t u32PktSize)
000000  65c1              STR      r1,[r0,#0x5c]
;;;474    {
;;;475        i2c->PKTSIZE = u32PktSize;
;;;476    }
000002  4770              BX       lr
;;;477    
                          ENDP


                          AREA ||i.I2C_SMBusTimeout||, CODE, READONLY, ALIGN=1

                  I2C_SMBusTimeout PROC
;;;605    
;;;606    void I2C_SMBusTimeout(I2C_T *i2c, uint32_t ms, uint32_t u32Pclk)
000000  b570              PUSH     {r4-r6,lr}
;;;607    {
000002  4604              MOV      r4,r0
;;;608        uint32_t u32Div, u32Pclk_kHz;
;;;609    
;;;610        i2c->BUSCTL &= ~I2C_BUSCTL_TIDLE_Msk;
000004  6d00              LDR      r0,[r0,#0x50]
000006  460d              MOV      r5,r1                 ;607
000008  2101              MOVS     r1,#1
00000a  0249              LSLS     r1,r1,#9
00000c  4388              BICS     r0,r0,r1
00000e  6520              STR      r0,[r4,#0x50]
;;;611    
;;;612        /* DIV4 disabled */
;;;613        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000010  6960              LDR      r0,[r4,#0x14]
000012  2604              MOVS     r6,#4
000014  43b0              BICS     r0,r0,r6
000016  6160              STR      r0,[r4,#0x14]
;;;614        u32Pclk_kHz = u32Pclk / 1000U;
000018  217d              MOVS     r1,#0x7d
00001a  00c9              LSLS     r1,r1,#3
00001c  4610              MOV      r0,r2
00001e  f7fffffe          BL       __aeabi_uidivmod
;;;615        u32Div = ((ms * u32Pclk_kHz) / (16U * 1024U)) - 1U;
000022  4345              MULS     r5,r0,r5
000024  0ba8              LSRS     r0,r5,#14
000026  1e40              SUBS     r0,r0,#1
;;;616        if(u32Div <= 0xFFU)
000028  28ff              CMP      r0,#0xff
00002a  d905              BLS      |L29.56|
;;;617        {
;;;618            i2c->BUSTOUT = u32Div;
;;;619        }
;;;620        else
;;;621        {
;;;622            /* DIV4 enabled */
;;;623            i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
00002c  6960              LDR      r0,[r4,#0x14]
00002e  4330              ORRS     r0,r0,r6
000030  6160              STR      r0,[r4,#0x14]
;;;624            i2c->BUSTOUT = (((ms * u32Pclk_kHz) / (16U * 1024U * 4U)) - 1U) & 0xFFU; /* The max value is 255 */
000032  0c28              LSRS     r0,r5,#16
000034  1e40              SUBS     r0,r0,#1
000036  b2c0              UXTB     r0,r0
                  |L29.56|
000038  6660              STR      r0,[r4,#0x64]         ;618
;;;625        }
;;;626    }
00003a  bd70              POP      {r4-r6,pc}
;;;627    
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;210     */
;;;211    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;212    {
000002  4605              MOV      r5,r0
;;;213        uint32_t u32Div;
;;;214        uint32_t u32Pclk;
;;;215    
;;;216        if (i2c == I2C1)
000004  480d              LDR      r0,|L30.60|
000006  460e              MOV      r6,r1                 ;212
000008  4285              CMP      r5,r0
00000a  d102              BNE      |L30.18|
;;;217        {
;;;218            u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L30.22|
                  |L30.18|
;;;219        }
;;;220        else
;;;221        {
;;;222            u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L30.22|
000016  4604              MOV      r4,r0
;;;223        }
;;;224    
;;;225        u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000018  220a              MOVS     r2,#0xa
00001a  00b1              LSLS     r1,r6,#2
00001c  4350              MULS     r0,r2,r0
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  210a              MOVS     r1,#0xa
000024  1d40              ADDS     r0,r0,#5
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  1e40              SUBS     r0,r0,#1
;;;226        i2c->CLKDIV = u32Div;
00002c  6128              STR      r0,[r5,#0x10]
;;;227    
;;;228        return (u32Pclk / ((u32Div + 1U) << 2U));
00002e  0081              LSLS     r1,r0,#2
000030  4620              MOV      r0,r4
000032  1d09              ADDS     r1,r1,#4
000034  f7fffffe          BL       __aeabi_uidivmod
;;;229    }
000038  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP

00003a  0000              DCW      0x0000
                  |L30.60|
                          DCD      0x40081000

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;282     */
;;;283    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;284    {
;;;285        i2c->DAT = u8Data;
;;;286    }
000002  4770              BX       lr
;;;287    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;301     */
;;;302    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  0052              LSLS     r2,r2,#1
;;;303    {
;;;304        switch (u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d006              BEQ      |L32.20|
000006  2902              CMP      r1,#2
000008  d006              BEQ      |L32.24|
00000a  2903              CMP      r1,#3
00000c  d006              BEQ      |L32.28|
;;;305        {
;;;306        case 1:
;;;307            i2c->ADDR1  = ((uint32_t)u8SlaveAddr << 1U);
;;;308            break;
;;;309    
;;;310        case 2:
;;;311            i2c->ADDR2  = ((uint32_t)u8SlaveAddr << 1U);
;;;312            break;
;;;313    
;;;314        case 3:
;;;315            i2c->ADDR3  = ((uint32_t)u8SlaveAddr << 1U);
;;;316            break;
;;;317    
;;;318        case 0:
;;;319        default:
;;;320            i2c->ADDR0  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
00000e  431a              ORRS     r2,r2,r3
000010  6042              STR      r2,[r0,#4]
;;;321            break;
;;;322        }
;;;323    }
000012  4770              BX       lr
                  |L32.20|
000014  6182              STR      r2,[r0,#0x18]         ;307
000016  4770              BX       lr
                  |L32.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;311
00001a  4770              BX       lr
                  |L32.28|
00001c  6202              STR      r2,[r0,#0x20]         ;315
00001e  4770              BX       lr
;;;324    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;336     */
;;;337    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;338    {
;;;339        switch (u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L33.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L33.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L33.26|
;;;340        {
;;;341        case 1:
;;;342            i2c->ADDRMSK1  = (uint32_t)u8SlaveAddrMask << 1U;
;;;343            break;
;;;344    
;;;345        case 2:
;;;346            i2c->ADDRMSK2  = (uint32_t)u8SlaveAddrMask << 1U;
;;;347            break;
;;;348    
;;;349        case 3:
;;;350            i2c->ADDRMSK3  = (uint32_t)u8SlaveAddrMask << 1U;
;;;351            break;
;;;352    
;;;353        case 0:
;;;354        default:
;;;355            i2c->ADDRMSK0  = (uint32_t)u8SlaveAddrMask << 1U;
00000e  6242              STR      r2,[r0,#0x24]
;;;356            break;
;;;357        }
;;;358    }
000010  4770              BX       lr
                  |L33.18|
000012  6282              STR      r2,[r0,#0x28]         ;342
000014  4770              BX       lr
                  |L33.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;346
000018  4770              BX       lr
                  |L33.26|
00001a  6302              STR      r2,[r0,#0x30]         ;350
00001c  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;117      */
;;;118    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;119    {
;;;120        uint32_t u32Reg = 0U;
000002  2400              MOVS     r4,#0
;;;121    
;;;122        if (u8Start)
000004  9d03              LDR      r5,[sp,#0xc]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L34.12|
;;;123        {
;;;124            u32Reg |= I2C_CTL_STA;
00000a  2420              MOVS     r4,#0x20
                  |L34.12|
;;;125        }
;;;126    
;;;127        if (u8Stop)
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L34.20|
;;;128        {
;;;129            u32Reg |= I2C_CTL_STO;
000010  2110              MOVS     r1,#0x10
000012  430c              ORRS     r4,r4,r1
                  |L34.20|
;;;130        }
;;;131    
;;;132        if (u8Si)
000014  2b00              CMP      r3,#0
000016  d001              BEQ      |L34.28|
;;;133        {
;;;134            u32Reg |= I2C_CTL_SI;
000018  2108              MOVS     r1,#8
00001a  430c              ORRS     r4,r4,r1
                  |L34.28|
;;;135        }
;;;136    
;;;137        if (u8Ack)
00001c  2d00              CMP      r5,#0
00001e  d001              BEQ      |L34.36|
;;;138        {
;;;139            u32Reg |= I2C_CTL_AA;
000020  2104              MOVS     r1,#4
000022  430c              ORRS     r4,r4,r1
                  |L34.36|
;;;140        }
;;;141    
;;;142        i2c->CTL0 = (i2c->CTL0 & ~0x3CU) | u32Reg;
000024  6801              LDR      r1,[r0,#0]
000026  223c              MOVS     r2,#0x3c
000028  4391              BICS     r1,r1,r2
00002a  4321              ORRS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
;;;143    }
00002e  bd30              POP      {r4,r5,pc}
;;;144    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;677    
;;;678    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;679    {
;;;680        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  2400              MOVS     r4,#0
;;;681    
;;;682        I2C_START(i2c);
000006  6806              LDR      r6,[r0,#0]
000008  4623              MOV      r3,r4                 ;680
00000a  2728              MOVS     r7,#0x28
00000c  433e              ORRS     r6,r6,r7
00000e  6006              STR      r6,[r0,#0]
;;;683    
;;;684        while (u8Xfering && (u8Err == 0U))
;;;685        {
;;;686            I2C_WAIT_READY(i2c) {}
;;;687    
;;;688            switch (I2C_GET_STATUS(i2c))
;;;689            {
;;;690            case 0x08:
;;;691                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Write SLA+W to Register I2CDAT */
;;;692                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;693                break;
;;;694    
;;;695            case 0x18:                                         /* Slave Address ACK */
;;;696                I2C_SET_DATA(i2c, data);                       /* Write data to I2CDAT */
;;;697                break;
;;;698    
;;;699            case 0x20:                                         /* Slave Address NACK */
;;;700            case 0x30:                                         /* Master transmit data NACK */
;;;701                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;702                u8Err = 1U;
;;;703                break;
;;;704    
;;;705            case 0x28:
;;;706                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;707                u8Xfering = 0U;
;;;708                break;
;;;709    
;;;710            case 0x38:                                         /* Arbitration Lost */
;;;711            default:                                           /* Unknow status */
;;;712                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L35.18|
000012  6807              LDR      r7,[r0,#0]            ;686
000014  073f              LSLS     r7,r7,#28             ;686
000016  d5fc              BPL      |L35.18|
000018  68c7              LDR      r7,[r0,#0xc]          ;688
00001a  2f20              CMP      r7,#0x20              ;688
00001c  d016              BEQ      |L35.76|
00001e  dc04              BGT      |L35.42|
000020  2f08              CMP      r7,#8                 ;688
000022  d00c              BEQ      |L35.62|
000024  2f18              CMP      r7,#0x18              ;688
000026  d104              BNE      |L35.50|
000028  e00e              B        |L35.72|
                  |L35.42|
00002a  2f28              CMP      r7,#0x28              ;688
00002c  d011              BEQ      |L35.82|
00002e  2f30              CMP      r7,#0x30              ;688
000030  d00c              BEQ      |L35.76|
                  |L35.50|
000032  6803              LDR      r3,[r0,#0]
000034  43b3              BICS     r3,r3,r6
000036  3318              ADDS     r3,r3,#0x18
000038  6003              STR      r3,[r0,#0]
;;;713                u8Ctrl = I2C_CTL_SI;
00003a  2308              MOVS     r3,#8
;;;714                u8Err = 1U;
;;;715                break;
00003c  e007              B        |L35.78|
                  |L35.62|
00003e  064b              LSLS     r3,r1,#25             ;691
000040  0e1b              LSRS     r3,r3,#24             ;691
000042  6083              STR      r3,[r0,#8]            ;691
000044  2308              MOVS     r3,#8                 ;692
000046  e006              B        |L35.86|
                  |L35.72|
000048  6082              STR      r2,[r0,#8]            ;696
00004a  e004              B        |L35.86|
                  |L35.76|
00004c  2318              MOVS     r3,#0x18              ;701
                  |L35.78|
00004e  2401              MOVS     r4,#1                 ;702
000050  e001              B        |L35.86|
                  |L35.82|
000052  2318              MOVS     r3,#0x18              ;706
000054  2500              MOVS     r5,#0                 ;707
                  |L35.86|
;;;716            }
;;;717    
;;;718            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
000056  6807              LDR      r7,[r0,#0]
000058  43b7              BICS     r7,r7,r6
00005a  431f              ORRS     r7,r7,r3
00005c  6007              STR      r7,[r0,#0]
00005e  2d00              CMP      r5,#0                 ;684
000060  d001              BEQ      |L35.102|
000062  2c00              CMP      r4,#0                 ;684
000064  d0d5              BEQ      |L35.18|
                  |L35.102|
000066  4620              MOV      r0,r4                 ;684
;;;719        }
;;;720    
;;;721        return (u8Err | u8Xfering);                            /* return (Success)/(Fail) status */
000068  4328              ORRS     r0,r0,r5
;;;722    }
00006a  bdf0              POP      {r4-r7,pc}
;;;723    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;802    
;;;803    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;804    {
000002  469e              MOV      lr,r3
;;;805        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2601              MOVS     r6,#1
000006  4613              MOV      r3,r2                 ;804
000008  2500              MOVS     r5,#0
;;;806        uint32_t u32txLen = 0U;
;;;807    
;;;808        I2C_START(i2c);                                        /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;804
00000e  462c              MOV      r4,r5                 ;805
000010  462f              MOV      r7,r5                 ;806
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;809    
;;;810        while (u8Xfering && (u8Err == 0U))
;;;811        {
;;;812            I2C_WAIT_READY(i2c) {}
;;;813    
;;;814            switch (I2C_GET_STATUS(i2c))
;;;815            {
;;;816            case 0x08:
;;;817                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Send Slave address with write bit */
;;;818                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;819                break;
;;;820    
;;;821            case 0x18:                                         /* Slave Address ACK */
;;;822                I2C_SET_DATA(i2c, u8DataAddr);                 /* Write Lo byte address of register */
;;;823                break;
;;;824    
;;;825            case 0x20:                                         /* Slave Address NACK */
;;;826            case 0x30:                                         /* Master transmit data NACK */
;;;827                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;828                u8Err = 1U;
;;;829                break;
;;;830    
;;;831            case 0x28:
;;;832                if (u32txLen < 1U)
;;;833                {
;;;834                    I2C_SET_DATA(i2c, data);
;;;835                    u32txLen++;
;;;836                }
;;;837                else
;;;838                {
;;;839                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;840                    u8Xfering = 0U;
;;;841                }
;;;842    
;;;843                break;
;;;844    
;;;845            case 0x38:                                         /* Arbitration Lost */
;;;846            default:                                           /* Unknow status */
;;;847                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L36.26|
00001a  6801              LDR      r1,[r0,#0]            ;812
00001c  0709              LSLS     r1,r1,#28             ;812
00001e  d5fc              BPL      |L36.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;814
000022  2920              CMP      r1,#0x20              ;814
000024  d017              BEQ      |L36.86|
000026  dc04              BGT      |L36.50|
000028  2908              CMP      r1,#8                 ;814
00002a  d00c              BEQ      |L36.70|
00002c  2918              CMP      r1,#0x18              ;814
00002e  d104              BNE      |L36.58|
000030  e00f              B        |L36.82|
                  |L36.50|
000032  2928              CMP      r1,#0x28              ;814
000034  d012              BEQ      |L36.92|
000036  2930              CMP      r1,#0x30              ;814
000038  d00d              BEQ      |L36.86|
                  |L36.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;848                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;849                u8Err = 1U;
;;;850                break;
000044  e008              B        |L36.88|
                  |L36.70|
000046  4661              MOV      r1,r12                ;817
000048  064c              LSLS     r4,r1,#25             ;817
00004a  0e24              LSRS     r4,r4,#24             ;817
00004c  6084              STR      r4,[r0,#8]            ;817
00004e  2408              MOVS     r4,#8                 ;818
000050  e00c              B        |L36.108|
                  |L36.82|
000052  6083              STR      r3,[r0,#8]            ;822
000054  e00a              B        |L36.108|
                  |L36.86|
000056  2418              MOVS     r4,#0x18              ;827
                  |L36.88|
000058  2501              MOVS     r5,#1                 ;828
00005a  e007              B        |L36.108|
                  |L36.92|
00005c  2f00              CMP      r7,#0                 ;832
00005e  d002              BEQ      |L36.102|
000060  2418              MOVS     r4,#0x18              ;839
000062  2600              MOVS     r6,#0                 ;840
000064  e002              B        |L36.108|
                  |L36.102|
000066  4671              MOV      r1,lr                 ;834
000068  6081              STR      r1,[r0,#8]            ;834
00006a  2701              MOVS     r7,#1                 ;835
                  |L36.108|
;;;851            }
;;;852    
;;;853            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
00006c  6801              LDR      r1,[r0,#0]
00006e  4391              BICS     r1,r1,r2
000070  4321              ORRS     r1,r1,r4
000072  6001              STR      r1,[r0,#0]
000074  2e00              CMP      r6,#0                 ;810
000076  d001              BEQ      |L36.124|
000078  2d00              CMP      r5,#0                 ;810
00007a  d0ce              BEQ      |L36.26|
                  |L36.124|
00007c  4628              MOV      r0,r5                 ;810
;;;854        }
;;;855    
;;;856        return (u8Err | u8Xfering);                            /* return (Success)/(Fail) status */
00007e  4330              ORRS     r0,r0,r6
;;;857    }
000080  bdf0              POP      {r4-r7,pc}
;;;858    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;942    
;;;943    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data)
000000  b5ff              PUSH     {r0-r7,lr}
;;;944    {
;;;945        uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  468e              MOV      lr,r1                 ;944
000006  2400              MOVS     r4,#0
;;;946        uint32_t u32txLen = 0U;
;;;947    
;;;948        I2C_START(i2c);                                                     /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;944
00000c  462f              MOV      r7,r5                 ;945
00000e  4623              MOV      r3,r4                 ;945
000010  4626              MOV      r6,r4                 ;946
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L37.24|
;;;949    
;;;950        while (u8Xfering && (u8Err == 0U))
;;;951        {
;;;952            I2C_WAIT_READY(i2c) {}
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L37.24|
;;;953    
;;;954            switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d01a              BEQ      |L37.90|
000024  dc04              BGT      |L37.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L37.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L37.56|
00002e  e010              B        |L37.82|
                  |L37.48|
000030  2a28              CMP      r2,#0x28
000032  d015              BEQ      |L37.96|
000034  2a30              CMP      r2,#0x30
000036  d010              BEQ      |L37.90|
                  |L37.56|
;;;955            {
;;;956            case 0x08:
;;;957                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));               /* Write SLA+W to Register I2CDAT */
;;;958                u8Ctrl = I2C_CTL_SI;                                        /* Clear SI */
;;;959                break;
;;;960    
;;;961            case 0x18:                                                      /* Slave Address ACK */
;;;962                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte address of register */
;;;963                break;
;;;964    
;;;965            case 0x20:                                                      /* Slave Address NACK */
;;;966            case 0x30:                                                      /* Master transmit data NACK */
;;;967                u8Ctrl = I2C_CTL_STO_SI;                                    /* Clear SI and send STOP */
;;;968                u8Err = 1;
;;;969                break;
;;;970    
;;;971            case 0x28:
;;;972                if (u8Addr)
;;;973                {
;;;974                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));       /* Write Lo byte address of register */
;;;975                    u8Addr = 0U;
;;;976                }
;;;977                else if ((u32txLen < 1U) && (u8Addr == 0U))
;;;978                {
;;;979                    I2C_SET_DATA(i2c, data);
;;;980                    u32txLen++;
;;;981                }
;;;982                else
;;;983                {
;;;984                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;985                    u8Xfering = 0U;
;;;986                }
;;;987    
;;;988                break;
;;;989    
;;;990            case 0x38:                                                      /* Arbitration Lost */
;;;991            default:                                                        /* Unknow status */
;;;992                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;993                u8Ctrl = I2C_CTL_SI;
000042  2308              MOVS     r3,#8
;;;994                u8Err = 1U;
;;;995                break;
000044  e00a              B        |L37.92|
                  |L37.70|
000046  4671              MOV      r1,lr                 ;957
000048  0649              LSLS     r1,r1,#25             ;957
00004a  0e09              LSRS     r1,r1,#24             ;957
00004c  6081              STR      r1,[r0,#8]            ;957
00004e  2308              MOVS     r3,#8                 ;958
000050  e015              B        |L37.126|
                  |L37.82|
000052  4661              MOV      r1,r12                ;962
000054  0a0a              LSRS     r2,r1,#8              ;962
000056  6082              STR      r2,[r0,#8]            ;962
000058  e011              B        |L37.126|
                  |L37.90|
00005a  2318              MOVS     r3,#0x18              ;967
                  |L37.92|
00005c  2401              MOVS     r4,#1                 ;968
00005e  e00e              B        |L37.126|
                  |L37.96|
000060  2f00              CMP      r7,#0                 ;972
000062  d004              BEQ      |L37.110|
000064  4661              MOV      r1,r12                ;974
000066  b2c9              UXTB     r1,r1                 ;974
000068  6081              STR      r1,[r0,#8]            ;974
00006a  2700              MOVS     r7,#0                 ;975
00006c  e007              B        |L37.126|
                  |L37.110|
00006e  2e00              CMP      r6,#0                 ;977
000070  d002              BEQ      |L37.120|
000072  2318              MOVS     r3,#0x18              ;984
000074  2500              MOVS     r5,#0                 ;985
000076  e002              B        |L37.126|
                  |L37.120|
000078  9903              LDR      r1,[sp,#0xc]          ;979
00007a  6081              STR      r1,[r0,#8]            ;979
00007c  2601              MOVS     r6,#1                 ;980
                  |L37.126|
;;;996            }
;;;997    
;;;998            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                               /* Write controlbit to I2C_CTL register */
00007e  6801              LDR      r1,[r0,#0]
000080  223c              MOVS     r2,#0x3c
000082  4391              BICS     r1,r1,r2
000084  460a              MOV      r2,r1
000086  431a              ORRS     r2,r2,r3
000088  6002              STR      r2,[r0,#0]
00008a  2d00              CMP      r5,#0                 ;950
00008c  d001              BEQ      |L37.146|
00008e  2c00              CMP      r4,#0                 ;950
000090  d0c2              BEQ      |L37.24|
                  |L37.146|
000092  4620              MOV      r0,r4                 ;950
;;;999        }
;;;1000   
;;;1001       return (u8Err | u8Xfering);                                         /* return (Success)/(Fail) status */
000094  4328              ORRS     r0,r0,r5
;;;1002   }
000096  b004              ADD      sp,sp,#0x10
000098  bdf0              POP      {r4-r7,pc}
;;;1003   
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;737    
;;;738    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;739    {
000002  469e              MOV      lr,r3
;;;740        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  4613              MOV      r3,r2                 ;739
000008  2600              MOVS     r6,#0
;;;741        uint32_t u32txLen = 0U;
;;;742    
;;;743        I2C_START(i2c);                                        /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;739
00000e  4634              MOV      r4,r6                 ;740
000010  4635              MOV      r5,r6                 ;741
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;744    
;;;745        while (u8Xfering && (u8Err == 0U))
;;;746        {
;;;747            I2C_WAIT_READY(i2c) {}
;;;748    
;;;749            switch (I2C_GET_STATUS(i2c))
;;;750            {
;;;751            case 0x08:
;;;752                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Write SLA+W to Register I2CDAT */
;;;753                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;754                break;
;;;755    
;;;756            case 0x18:                                         /* Slave Address ACK */
;;;757            case 0x28:
;;;758                if (u32txLen < u32wLen)
;;;759                    I2C_SET_DATA(i2c, data[u32txLen++]);       /* Write Data to I2CDAT */
;;;760                else
;;;761                {
;;;762                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;763                    u8Xfering = 0U;
;;;764                }
;;;765    
;;;766                break;
;;;767    
;;;768            case 0x20:                                         /* Slave Address NACK */
;;;769            case 0x30:                                         /* Master transmit data NACK */
;;;770                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;771                u8Err = 1U;
;;;772                break;
;;;773    
;;;774            case 0x38:                                         /* Arbitration Lost */
;;;775            default:                                           /* Unknow status */
;;;776                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L38.26|
00001a  6801              LDR      r1,[r0,#0]            ;747
00001c  0709              LSLS     r1,r1,#28             ;747
00001e  d5fc              BPL      |L38.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;749
000022  2920              CMP      r1,#0x20              ;749
000024  d01e              BEQ      |L38.100|
000026  dc04              BGT      |L38.50|
000028  2908              CMP      r1,#8                 ;749
00002a  d00c              BEQ      |L38.70|
00002c  2918              CMP      r1,#0x18              ;749
00002e  d104              BNE      |L38.58|
000030  e00f              B        |L38.82|
                  |L38.50|
000032  2928              CMP      r1,#0x28              ;749
000034  d00d              BEQ      |L38.82|
000036  2930              CMP      r1,#0x30              ;749
000038  d014              BEQ      |L38.100|
                  |L38.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;777                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;778                u8Err = 1U;
;;;779                break;
000044  e00f              B        |L38.102|
                  |L38.70|
000046  4661              MOV      r1,r12                ;752
000048  064c              LSLS     r4,r1,#25             ;752
00004a  0e24              LSRS     r4,r4,#24             ;752
00004c  6084              STR      r4,[r0,#8]            ;752
00004e  2408              MOVS     r4,#8                 ;753
000050  e00a              B        |L38.104|
                  |L38.82|
000052  4575              CMP      r5,lr                 ;758
000054  d203              BCS      |L38.94|
000056  5d59              LDRB     r1,[r3,r5]            ;759
000058  6081              STR      r1,[r0,#8]            ;759
00005a  1c6d              ADDS     r5,r5,#1              ;759
00005c  e004              B        |L38.104|
                  |L38.94|
00005e  2418              MOVS     r4,#0x18              ;762
000060  2700              MOVS     r7,#0                 ;763
000062  e001              B        |L38.104|
                  |L38.100|
000064  2418              MOVS     r4,#0x18              ;770
                  |L38.102|
000066  2601              MOVS     r6,#1                 ;771
                  |L38.104|
;;;780            }
;;;781    
;;;782            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
000068  6801              LDR      r1,[r0,#0]
00006a  4391              BICS     r1,r1,r2
00006c  4321              ORRS     r1,r1,r4
00006e  6001              STR      r1,[r0,#0]
000070  2f00              CMP      r7,#0                 ;745
000072  d001              BEQ      |L38.120|
000074  2e00              CMP      r6,#0                 ;745
000076  d0d0              BEQ      |L38.26|
                  |L38.120|
;;;783        }
;;;784    
;;;785        return u32txLen;                                       /* Return bytes length that have been transmitted */
000078  4628              MOV      r0,r5
;;;786    }
00007a  bdf0              POP      {r4-r7,pc}
;;;787    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;874    
;;;875    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;876    {
000002  469e              MOV      lr,r3
;;;877        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  460b              MOV      r3,r1                 ;876
000008  2600              MOVS     r6,#0
;;;878        uint32_t u32txLen = 0U;
;;;879    
;;;880        I2C_START(i2c);                                           /* Send START */
00000a  6801              LDR      r1,[r0,#0]
00000c  4694              MOV      r12,r2                ;876
00000e  4634              MOV      r4,r6                 ;877
000010  4635              MOV      r5,r6                 ;878
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;881    
;;;882        while (u8Xfering && (u8Err == 0U))
;;;883        {
;;;884            I2C_WAIT_READY(i2c) {}
;;;885    
;;;886            switch (I2C_GET_STATUS(i2c))
;;;887            {
;;;888            case 0x08:
;;;889                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
;;;890                u8Ctrl = I2C_CTL_SI;
;;;891                break;
;;;892    
;;;893            case 0x18:                                           /* Slave Address ACK */
;;;894                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;895                break;
;;;896    
;;;897            case 0x20:                                           /* Slave Address NACK */
;;;898            case 0x30:                                           /* Master transmit data NACK */
;;;899                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;900                u8Err = 1U;
;;;901                break;
;;;902    
;;;903            case 0x28:
;;;904                if (u32txLen < u32wLen)
;;;905                    I2C_SET_DATA(i2c, data[u32txLen++]);
;;;906                else
;;;907                {
;;;908                    u8Ctrl = I2C_CTL_STO_SI;                     /* Clear SI and send STOP */
;;;909                    u8Xfering = 0U;
;;;910                }
;;;911    
;;;912                break;
;;;913    
;;;914            case 0x38:                                           /* Arbitration Lost */
;;;915            default:                                             /* Unknow status */
;;;916                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L39.26|
00001a  6801              LDR      r1,[r0,#0]            ;884
00001c  0709              LSLS     r1,r1,#28             ;884
00001e  d5fc              BPL      |L39.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;886
000022  2920              CMP      r1,#0x20              ;886
000024  d017              BEQ      |L39.86|
000026  dc04              BGT      |L39.50|
000028  2908              CMP      r1,#8                 ;886
00002a  d00c              BEQ      |L39.70|
00002c  2918              CMP      r1,#0x18              ;886
00002e  d104              BNE      |L39.58|
000030  e00e              B        |L39.80|
                  |L39.50|
000032  2928              CMP      r1,#0x28              ;886
000034  d012              BEQ      |L39.92|
000036  2930              CMP      r1,#0x30              ;886
000038  d00d              BEQ      |L39.86|
                  |L39.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;917                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;918                u8Err = 1U;
;;;919                break;
000044  e008              B        |L39.88|
                  |L39.70|
000046  065c              LSLS     r4,r3,#25             ;889
000048  0e24              LSRS     r4,r4,#24             ;889
00004a  6084              STR      r4,[r0,#8]            ;889
00004c  2408              MOVS     r4,#8                 ;890
00004e  e00f              B        |L39.112|
                  |L39.80|
000050  4661              MOV      r1,r12                ;894
000052  6081              STR      r1,[r0,#8]            ;894
000054  e00c              B        |L39.112|
                  |L39.86|
000056  2418              MOVS     r4,#0x18              ;899
                  |L39.88|
000058  2601              MOVS     r6,#1                 ;900
00005a  e009              B        |L39.112|
                  |L39.92|
00005c  9905              LDR      r1,[sp,#0x14]         ;904
00005e  428d              CMP      r5,r1                 ;904
000060  d204              BCS      |L39.108|
000062  4671              MOV      r1,lr                 ;905
000064  5d49              LDRB     r1,[r1,r5]            ;905
000066  6081              STR      r1,[r0,#8]            ;905
000068  1c6d              ADDS     r5,r5,#1              ;905
00006a  e001              B        |L39.112|
                  |L39.108|
00006c  2418              MOVS     r4,#0x18              ;908
00006e  2700              MOVS     r7,#0                 ;909
                  |L39.112|
;;;920            }
;;;921    
;;;922            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000070  6801              LDR      r1,[r0,#0]
000072  4391              BICS     r1,r1,r2
000074  4321              ORRS     r1,r1,r4
000076  6001              STR      r1,[r0,#0]
000078  2f00              CMP      r7,#0                 ;882
00007a  d001              BEQ      |L39.128|
00007c  2e00              CMP      r6,#0                 ;882
00007e  d0cc              BEQ      |L39.26|
                  |L39.128|
;;;923        }
;;;924    
;;;925        return u32txLen;                                         /* Return bytes length that have been transmitted */
000080  4628              MOV      r0,r5
;;;926    }
000082  bdf0              POP      {r4-r7,pc}
;;;927    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;1019   
;;;1020   uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data[], uint32_t u32wLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1021   {
;;;1022       uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2701              MOVS     r7,#1
000004  468e              MOV      lr,r1                 ;1021
000006  2500              MOVS     r5,#0
;;;1023       uint32_t u32txLen = 0U;
;;;1024   
;;;1025       I2C_START(i2c);                                                     /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;1021
00000c  463e              MOV      r6,r7                 ;1022
00000e  462b              MOV      r3,r5                 ;1022
000010  462c              MOV      r4,r5                 ;1023
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L40.24|
;;;1026   
;;;1027       while (u8Xfering && (u8Err == 0U))
;;;1028       {
;;;1029           I2C_WAIT_READY(i2c) {}
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L40.24|
;;;1030   
;;;1031           switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d01a              BEQ      |L40.90|
000024  dc04              BGT      |L40.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L40.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L40.56|
00002e  e010              B        |L40.82|
                  |L40.48|
000030  2a28              CMP      r2,#0x28
000032  d015              BEQ      |L40.96|
000034  2a30              CMP      r2,#0x30
000036  d010              BEQ      |L40.90|
                  |L40.56|
;;;1032           {
;;;1033           case 0x08:
;;;1034               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));               /* Write SLA+W to Register I2CDAT */
;;;1035               u8Ctrl = I2C_CTL_SI;                                        /* Clear SI */
;;;1036               break;
;;;1037   
;;;1038           case 0x18:                                                      /* Slave Address ACK */
;;;1039               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte address of register */
;;;1040               break;
;;;1041   
;;;1042           case 0x20:                                                      /* Slave Address NACK */
;;;1043           case 0x30:                                                      /* Master transmit data NACK */
;;;1044               u8Ctrl = I2C_CTL_STO_SI;                                    /* Clear SI and send STOP */
;;;1045               u8Err = 1U;
;;;1046               break;
;;;1047   
;;;1048           case 0x28:
;;;1049               if (u8Addr)
;;;1050               {
;;;1051                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));       /* Write Lo byte address of register */
;;;1052                   u8Addr = 0U;
;;;1053               }
;;;1054               else if ((u32txLen < u32wLen) && (u8Addr == 0U))
;;;1055                   I2C_SET_DATA(i2c, data[u32txLen++]);                    /* Write data to Register I2CDAT*/
;;;1056               else
;;;1057               {
;;;1058                   u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;1059                   u8Xfering = 0U;
;;;1060               }
;;;1061   
;;;1062               break;
;;;1063   
;;;1064           case 0x38:                                                      /* Arbitration Lost */
;;;1065           default:                                                        /* Unknow status */
;;;1066               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;1067               u8Ctrl = I2C_CTL_SI;
000042  2308              MOVS     r3,#8
;;;1068               u8Err = 1U;
;;;1069               break;
000044  e00a              B        |L40.92|
                  |L40.70|
000046  4671              MOV      r1,lr                 ;1034
000048  0649              LSLS     r1,r1,#25             ;1034
00004a  0e09              LSRS     r1,r1,#24             ;1034
00004c  6081              STR      r1,[r0,#8]            ;1034
00004e  2308              MOVS     r3,#8                 ;1035
000050  e017              B        |L40.130|
                  |L40.82|
000052  4661              MOV      r1,r12                ;1039
000054  0a0a              LSRS     r2,r1,#8              ;1039
000056  6082              STR      r2,[r0,#8]            ;1039
000058  e013              B        |L40.130|
                  |L40.90|
00005a  2318              MOVS     r3,#0x18              ;1044
                  |L40.92|
00005c  2501              MOVS     r5,#1                 ;1045
00005e  e010              B        |L40.130|
                  |L40.96|
000060  2e00              CMP      r6,#0                 ;1049
000062  d004              BEQ      |L40.110|
000064  4661              MOV      r1,r12                ;1051
000066  b2c9              UXTB     r1,r1                 ;1051
000068  6081              STR      r1,[r0,#8]            ;1051
00006a  2600              MOVS     r6,#0                 ;1052
00006c  e009              B        |L40.130|
                  |L40.110|
00006e  9a09              LDR      r2,[sp,#0x24]         ;1054
000070  4294              CMP      r4,r2                 ;1054
000072  d204              BCS      |L40.126|
000074  9a03              LDR      r2,[sp,#0xc]          ;1055
000076  5d12              LDRB     r2,[r2,r4]            ;1055
000078  6082              STR      r2,[r0,#8]            ;1055
00007a  1c64              ADDS     r4,r4,#1              ;1055
00007c  e001              B        |L40.130|
                  |L40.126|
00007e  2318              MOVS     r3,#0x18              ;1058
000080  2700              MOVS     r7,#0                 ;1059
                  |L40.130|
;;;1070           }
;;;1071   
;;;1072           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                               /* Write controlbit to I2C_CTL register */
000082  6801              LDR      r1,[r0,#0]
000084  223c              MOVS     r2,#0x3c
000086  4391              BICS     r1,r1,r2
000088  460a              MOV      r2,r1
00008a  431a              ORRS     r2,r2,r3
00008c  6002              STR      r2,[r0,#0]
00008e  2f00              CMP      r7,#0                 ;1027
000090  d001              BEQ      |L40.150|
000092  2d00              CMP      r5,#0                 ;1027
000094  d0c0              BEQ      |L40.24|
                  |L40.150|
;;;1073       }
;;;1074   
;;;1075       return u32txLen;                                                    /* Return bytes length that have been transmitted */
000096  4620              MOV      r0,r4
;;;1076   }
000098  b004              ADD      sp,sp,#0x10
00009a  bdf0              POP      {r4-r7,pc}
;;;1077   
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L247.16|
00000e  461d              MOV      r5,r3
                  |L247.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 402
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
